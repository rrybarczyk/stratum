use common_messages_sv2::{SetupConnection, SetupConnectionError};
use mining_sv2;
use v1::{
    client_to_server,
    error::Error,
    json_rpc,
    methods::Client2Server,
    server_to_client,
    utils::{HexBytes, HexU32Be},
    IsServer,
};
struct Pool;

struct Server {
    pool: Pool,
}

pub enum Sv2Message {}

impl Server {
    /// Sends Sv2 formatted message to a Sv2 upstream.
    fn send_to_sv2_upstream(&mut self) -> Sv2Message {
        todo!()
    }

    /// Transforms a Sv1 `subscribe` message into an Sv2 `OpenExtendedChannel` message.
    fn transform_subscribe() -> mining_sv2::OpenExtendedMiningChannel<'static> {
        todo!()
    }

    /// Transforms a Sv2 `OpenExtendedChannelSuccess` message to a Sv1 message.
    fn transform_open_extended_channel_success(response: ()) -> json_rpc::Message {
        todo!()
    }
}

impl IsServer for Server {
    /// Deserialize a [raw json_rpc message] into a [stratum v1 message] and handle the result.
    fn handle_message(
        &mut self,
        msg: json_rpc::Message,
    ) -> Result<Option<json_rpc::Response>, Error>
    where
        Self: std::marker::Sized,
    {
        todo!()
    }

    /// Call the handler associated with the request called method.
    fn handle_request(
        &mut self,
        request: Client2Server,
    ) -> Result<Option<json_rpc::Response>, Error>
    where
        Self: std::marker::Sized,
    {
        todo!()
    }

    /// This message (JSON RPC Request) SHOULD be the first message sent by the miner after the
    /// connection with the server is established.
    fn handle_configure(
        &mut self,
        request: &client_to_server::Configure,
    ) -> (Option<server_to_client::VersionRollingParams>, Option<bool>) {
        todo!()
    }

    /// On the beginning of the session, the client subscribes to the current connection for
    /// receiving mining jobs.
    ///
    /// The client can specify the `[mining.notify]`[a] `job_id` the client wishes to resume
    /// working with.
    ///
    /// The result contains three items:
    /// * Subscriptions details: 2-tuple with name of subscribed notification and subscription ID.
    ///   Teoretically it may be used for unsubscribing, but obviously miners won't use it.
    /// * Extranonce1 - Hex-encoded, per-connection unique string which will be used for coinbase
    ///   serialization later. Keep it safe!
    /// * Extranonce2_size - Represents expected length of extranonce2 which will be generated by
    ///   the miner.
    ///
    /// Almost instantly after the subscription server start to send [jobs][a]
    ///
    /// This function return the first item of the result (2 tuple with name of subscibed ...)
    ///
    /// [a]: crate::methods::server_to_client::Notify
    fn handle_subscribe(&self, request: &client_to_server::Subscribe) -> Vec<(String, String)> {
        todo!()
    }

    fn handle_authorize(&self, request: &client_to_server::Authorize) -> bool {
        todo!()
    }

    fn handle_submit(&self, request: &client_to_server::Submit) -> bool {
        todo!()
    }

    fn handle_extranonce_subscribe(&self) {
        todo!()
    }

    fn is_authorized(&self, name: &str) -> bool {
        todo!()
    }

    fn authorize(&mut self, name: &str) {
        todo!()
    }

    /// Set extranonce1 to extranonce1 if provided. If not create a new one and set it.
    fn set_extranonce1(&mut self, extranonce1: Option<HexBytes>) -> HexBytes {
        todo!()
    }

    fn extranonce1(&self) -> HexBytes {
        todo!()
    }

    /// Set extranonce2_size to extranonce2_size if provided. If not create a new one and set it.
    fn set_extranonce2_size(&mut self, extra_nonce2_size: Option<usize>) -> usize {
        todo!()
    }

    fn extranonce2_size(&self) -> usize {
        todo!()
    }

    fn version_rolling_mask(&self) -> Option<HexU32Be> {
        todo!()
    }

    fn set_version_rolling_mask(&mut self, mask: Option<HexU32Be>) {
        todo!()
    }

    fn set_version_rolling_min_bit(&mut self, mask: Option<HexU32Be>) {
        todo!()
    }
}

fn main() {
    println!("Hello, world!");
}
